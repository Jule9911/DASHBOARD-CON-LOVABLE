# -*- coding: utf-8 -*-
"""LOVABLE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1khm1Jm_MEVxlDMtblxZwd03rf6pRuXmM

**SIMULACIÓN 50000 DATOS**
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import random
from typing import Dict, List, Tuple

class DatasetGenerator:
    def __init__(self):
        # ... keep existing code (parameters definition and fault_codes) the same
        self.parameters = {
            'presion_aceite': {
                'ideal': 5,
                'min': 2,
                'max': 7,
                'falla_alta': 'F02',  # >7 psi
                'falla_baja': 'F01'   # <2 psi
            },
            'voltaje_bateria': {
                'ideal': 13,
                'min': 10,
                'max': 14,
                'falla_alta': 'F04',  # >14V
                'falla_baja': 'F03'   # <10V
            },
            'voltaje_alternador': {
                'ideal': 14,
                'min': 12,
                'max': 16,
                'falla_alta': 'F06',  # >16V
                'falla_baja': 'F05'   # <12V
            },
            'temp_vacio': {
                'ideal': 70,
                'min': 50,
                'max': 76,
                'falla_alta': 'F08',  # >76°C
                'falla_baja': 'F07'   # <50°C
            },
            'temp_carga': {
                'ideal': 80,
                'min': 70,
                'max': 90,
                'falla_alta': 'F10',  # >90°C
                'falla_baja': 'F09'   # <70°C
            },
            'nivel_refrigerante': {
                'ideal': 1,  # Sin alarma
                'min': 0,    # BAJO
                'max': 1,    # LLENO
                'falla_baja': 'F11'  # BAJO
            }
        }

        # Códigos de falla
        self.fault_codes = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'F11']

        # Mapear fallas que afectan al mismo parámetro (mutuamente excluyentes)
        self.conflicting_faults = {
            'F01': 'F02',  # Presión aceite baja vs alta
            'F02': 'F01',  # Presión aceite alta vs baja
            'F03': 'F04',  # Voltaje batería bajo vs alto
            'F04': 'F03',  # Voltaje batería alto vs bajo
            'F05': 'F06',  # Voltaje alternador bajo vs alto
            'F06': 'F05',  # Voltaje alternador alto vs bajo
            'F07': 'F08',  # Temp vacío baja vs alta
            'F08': 'F07',  # Temp vacío alta vs baja
            'F09': 'F10',  # Temp carga baja vs alta
            'F10': 'F09'   # Temp carga alta vs baja
        }

    # ... keep existing code (generate_normal_sample, generate_fault_sample, get_compatible_faults, generate_multiple_faults_sample methods) the same
    def generate_normal_sample(self) -> Dict:
        """Genera una muestra con parámetros normales (sin fallas)"""
        sample = {}

        # Generar valores normales para cada parámetro
        sample['presion_aceite'] = round(np.random.uniform(2.1, 6.9), 2)
        sample['voltaje_bateria'] = round(np.random.uniform(10.1, 13.9), 2)
        sample['voltaje_alternador'] = round(np.random.uniform(12.1, 15.9), 2)
        sample['temp_vacio'] = round(np.random.uniform(50.1, 75.9), 2)
        sample['temp_carga'] = round(np.random.uniform(70.1, 89.9), 2)
        sample['nivel_refrigerante'] = 1  # Sin alarma

        # Inicializar todas las fallas en 0
        for code in self.fault_codes:
            sample[code] = 0

        return sample

    def generate_fault_sample(self, fault_type: str) -> Dict:
        """Genera una muestra con una falla específica"""
        sample = self.generate_normal_sample()

        # Activar la falla específica
        sample[fault_type] = 1

        # Ajustar el parámetro correspondiente para que coincida con la falla
        if fault_type == 'F01':  # Presión aceite baja
            sample['presion_aceite'] = round(np.random.uniform(0.5, 1.9), 2)
        elif fault_type == 'F02':  # Presión aceite alta
            sample['presion_aceite'] = round(np.random.uniform(7.1, 10.0), 2)
        elif fault_type == 'F03':  # Voltaje batería bajo
            sample['voltaje_bateria'] = round(np.random.uniform(5.0, 9.9), 2)
        elif fault_type == 'F04':  # Voltaje batería alto
            sample['voltaje_bateria'] = round(np.random.uniform(14.1, 18.0), 2)
        elif fault_type == 'F05':  # Voltaje alternador bajo
            sample['voltaje_alternador'] = round(np.random.uniform(8.0, 11.9), 2)
        elif fault_type == 'F06':  # Voltaje alternador alto
            sample['voltaje_alternador'] = round(np.random.uniform(16.1, 20.0), 2)
        elif fault_type == 'F07':  # Temperatura vacío baja
            sample['temp_vacio'] = round(np.random.uniform(20.0, 49.9), 2)
        elif fault_type == 'F08':  # Temperatura vacío alta
            sample['temp_vacio'] = round(np.random.uniform(76.1, 120.0), 2)
        elif fault_type == 'F09':  # Temperatura carga baja
            sample['temp_carga'] = round(np.random.uniform(40.0, 69.9), 2)
        elif fault_type == 'F10':  # Temperatura carga alta
            sample['temp_carga'] = round(np.random.uniform(90.1, 130.0), 2)
        elif fault_type == 'F11':  # Nivel refrigerante bajo
            sample['nivel_refrigerante'] = 0

        return sample

    def get_compatible_faults(self, fault_types: List[str]) -> List[str]:
        """Filtra fallas compatibles (que no se contradigan entre sí)"""
        compatible_faults = []

        for fault in fault_types:
            # Verificar si esta falla es compatible con las ya seleccionadas
            is_compatible = True
            for existing_fault in compatible_faults:
                # Verificar si son fallas conflictivas (afectan al mismo parámetro)
                if fault in self.conflicting_faults and self.conflicting_faults[fault] == existing_fault:
                    is_compatible = False
                    break

            if is_compatible:
                compatible_faults.append(fault)

        return compatible_faults

    def generate_multiple_faults_sample(self, fault_types: List[str]) -> Dict:
        """Genera una muestra con múltiples fallas compatibles"""
        sample = self.generate_normal_sample()

        # Filtrar solo fallas compatibles
        compatible_faults = self.get_compatible_faults(fault_types)

        # Si no hay fallas compatibles, generar una sola falla aleatoria
        if len(compatible_faults) < 2:
            fault_type = random.choice(fault_types)
            return self.generate_fault_sample(fault_type)

        # Activar fallas compatibles
        for fault_type in compatible_faults:
            sample[fault_type] = 1

            # Ajustar parámetros según cada falla
            if fault_type == 'F01':  # Presión aceite baja
                sample['presion_aceite'] = round(np.random.uniform(0.5, 1.9), 2)
            elif fault_type == 'F02':  # Presión aceite alta
                sample['presion_aceite'] = round(np.random.uniform(7.1, 10.0), 2)
            elif fault_type == 'F03':  # Voltaje batería bajo
                sample['voltaje_bateria'] = round(np.random.uniform(5.0, 9.9), 2)
            elif fault_type == 'F04':  # Voltaje batería alto
                sample['voltaje_bateria'] = round(np.random.uniform(14.1, 18.0), 2)
            elif fault_type == 'F05':  # Voltaje alternador bajo
                sample['voltaje_alternador'] = round(np.random.uniform(8.0, 11.9), 2)
            elif fault_type == 'F06':  # Voltaje alternador alto
                sample['voltaje_alternador'] = round(np.random.uniform(16.1, 20.0), 2)
            elif fault_type == 'F07':  # Temperatura vacío baja
                sample['temp_vacio'] = round(np.random.uniform(20.0, 49.9), 2)
            elif fault_type == 'F08':  # Temperatura vacío alta
                sample['temp_vacio'] = round(np.random.uniform(76.1, 120.0), 2)
            elif fault_type == 'F09':  # Temperatura carga baja
                sample['temp_carga'] = round(np.random.uniform(40.0, 69.9), 2)
            elif fault_type == 'F10':  # Temperatura carga alta
                sample['temp_carga'] = round(np.random.uniform(90.1, 130.0), 2)
            elif fault_type == 'F11':  # Nivel refrigerante bajo
                sample['nivel_refrigerante'] = 0

        return sample

    def generate_dataset(self, total_samples: int = 50000) -> pd.DataFrame:
        """Genera el dataset completo"""
        samples = []

        # Distribución de muestras
        normal_samples = int(total_samples * 0.5)  # 50% normales
        single_fault_samples = int(total_samples * 0.3)  # 30% falla única
        multiple_fault_samples = int(total_samples * 0.20)  # 20% fallas múltiples

        print(f"Generando {total_samples} muestras:")
        print(f"- {normal_samples} muestras normales")
        print(f"- {single_fault_samples} muestras con falla única")
        print(f"- {multiple_fault_samples} muestras con fallas múltiples")

        # Generar muestras normales
        print("Generando muestras normales...")
        for i in range(normal_samples):
            samples.append(self.generate_normal_sample())
            if (i + 1) % 5000 == 0:
                print(f"  Generadas {i + 1}/{normal_samples} muestras normales")

        # Generar muestras con falla única
        print("Generando muestras con falla única...")
        for i in range(single_fault_samples):
            fault_type = random.choice(self.fault_codes)
            samples.append(self.generate_fault_sample(fault_type))
            if (i + 1) % 5000 == 0:
                print(f"  Generadas {i + 1}/{single_fault_samples} muestras con falla única")

        # Generar muestras con fallas múltiples
        print("Generando muestras con fallas múltiples...")
        for i in range(multiple_fault_samples):
            # Generar entre 2 y 4 fallas, pero asegurar compatibilidad
            max_attempts = 10
            for attempt in range(max_attempts):
                num_faults = random.randint(2, 4)
                fault_types = random.sample(self.fault_codes, num_faults)
                compatible_faults = self.get_compatible_faults(fault_types)

                if len(compatible_faults) >= 2:
                    samples.append(self.generate_multiple_faults_sample(fault_types))
                    break
            else:
                # Si no se pueden generar fallas múltiples compatibles, generar una sola
                fault_type = random.choice(self.fault_codes)
                samples.append(self.generate_fault_sample(fault_type))

            if (i + 1) % 1000 == 0:
                print(f"  Generadas {i + 1}/{multiple_fault_samples} muestras con fallas múltiples")

        print("Creando DataFrame...")
        # Crear DataFrame
        df = pd.DataFrame(samples)

        # Reordenar columnas
        param_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                        'temp_vacio', 'temp_carga', 'nivel_refrigerante']
        fault_columns = self.fault_codes
        df = df[param_columns + fault_columns]

        print("Mezclando filas...")
        # Mezclar las filas
        df = df.sample(frac=1).reset_index(drop=True)

        return df

    # ... keep existing code (validate_dataset and print_statistics methods) the same
    def validate_dataset(self, df: pd.DataFrame) -> bool:
        """Valida que el dataset no tenga contradicciones"""
        print("\nValidando dataset...")
        contradictions = 0

        for idx, row in df.iterrows():
            # Validar cada falla
            if row['F01'] == 1 and row['presion_aceite'] >= 2:
                print(f"Contradicción en fila {idx}: F01=1 pero presión_aceite={row['presion_aceite']} >= 2")
                contradictions += 1

            if row['F02'] == 1 and row['presion_aceite'] <= 7:
                print(f"Contradicción en fila {idx}: F02=1 pero presión_aceite={row['presion_aceite']} <= 7")
                contradictions += 1

            if row['F03'] == 1 and row['voltaje_bateria'] >= 10:
                print(f"Contradicción en fila {idx}: F03=1 pero voltaje_bateria={row['voltaje_bateria']} >= 10")
                contradictions += 1

            if row['F04'] == 1 and row['voltaje_bateria'] <= 14:
                print(f"Contradicción en fila {idx}: F04=1 pero voltaje_bateria={row['voltaje_bateria']} <= 14")
                contradictions += 1

            if row['F05'] == 1 and row['voltaje_alternador'] >= 12:
                print(f"Contradicción en fila {idx}: F05=1 pero voltaje_alternador={row['voltaje_alternador']} >= 12")
                contradictions += 1

            if row['F06'] == 1 and row['voltaje_alternador'] <= 16:
                print(f"Contradicción en fila {idx}: F06=1 pero voltaje_alternador={row['voltaje_alternador']} <= 16")
                contradictions += 1

            if row['F07'] == 1 and row['temp_vacio'] >= 50:
                print(f"Contradicción en fila {idx}: F07=1 pero temp_vacio={row['temp_vacio']} >= 50")
                contradictions += 1

            if row['F08'] == 1 and row['temp_vacio'] <= 76:
                print(f"Contradicción en fila {idx}: F08=1 pero temp_vacio={row['temp_vacio']} <= 76")
                contradictions += 1

            if row['F09'] == 1 and row['temp_carga'] >= 70:
                print(f"Contradicción en fila {idx}: F09=1 pero temp_carga={row['temp_carga']} >= 70")
                contradictions += 1

            if row['F10'] == 1 and row['temp_carga'] <= 90:
                print(f"Contradicción en fila {idx}: F10=1 pero temp_carga={row['temp_carga']} <= 90")
                contradictions += 1

            if row['F11'] == 1 and row['nivel_refrigerante'] != 0:
                print(f"Contradicción en fila {idx}: F11=1 pero nivel_refrigerante={row['nivel_refrigerante']} != 0")
                contradictions += 1

        if contradictions == 0:
            print("✅ Dataset validado: No hay contradicciones")
            return True
        else:
            print(f"❌ Se encontraron {contradictions} contradicciones")
            return False

    def print_statistics(self, df: pd.DataFrame):
        """Imprime estadísticas del dataset"""
        print("\n=== ESTADÍSTICAS DEL DATASET ===")
        print(f"Total de muestras: {len(df)}")

        # Estadísticas de fallas
        print("\nDistribución de fallas:")
        for code in self.fault_codes:
            count = df[code].sum()
            percentage = (count / len(df)) * 100
            print(f"{code}: {count} muestras ({percentage:.1f}%)")

        # Muestras sin fallas
        no_faults = df[self.fault_codes].sum(axis=1) == 0
        no_fault_count = no_faults.sum()
        no_fault_percentage = (no_fault_count / len(df)) * 100
        print(f"Sin fallas: {no_fault_count} muestras ({no_fault_percentage:.1f}%)")

        # Estadísticas de parámetros
        print("\nEstadísticas de parámetros:")
        param_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                        'temp_vacio', 'temp_carga', 'nivel_refrigerante']

        for param in param_columns:
            print(f"\n{param}:")
            print(f"  Min: {df[param].min()}")
            print(f"  Max: {df[param].max()}")
            print(f"  Media: {df[param].mean():.2f}")
            print(f"  Desv. Std: {df[param].std():.2f}")

def main():
    # Crear generador
    generator = DatasetGenerator()

    # Generar dataset de 50,000 muestras
    print("Iniciando generación del dataset...")
    df = generator.generate_dataset(total_samples=50000)

    # Validar dataset
    is_valid = generator.validate_dataset(df)

    if is_valid:
        # Guardar dataset
        filename = "dataset_entrenamiento_50k.csv"
        print(f"\nGuardando dataset como: {filename}...")
        df.to_csv(filename, index=False)
        print(f"✅ Dataset guardado como: {filename}")

        # Imprimir estadísticas
        generator.print_statistics(df)

        # Mostrar primeras 10 filas
        print("\n=== PRIMERAS 10 FILAS DEL DATASET ===")
        print(df.head(10).to_string())

    else:
        print("\n❌ El dataset contiene contradicciones. Revisa la lógica de generación.")

if __name__ == "__main__":
    main()

"""**SIMULACIÓN 1000 DATOS PARA PRUEBA/MATRIZ DE CONFUSIÓN**"""

import pandas as pd
import numpy as np
import random
from typing import Dict, List, Tuple

class DatasetGenerator:
    def __init__(self):
        # Definir los rangos y condiciones de falla
        self.parameters = {
            'presion_aceite': {
                'ideal': 5,
                'min': 2,
                'max': 7,
                'falla_alta': 'F02',  # >7 psi
                'falla_baja': 'F01'   # <2 psi
            },
            'voltaje_bateria': {
                'ideal': 13,
                'min': 10,
                'max': 14,
                'falla_alta': 'F04',  # >14V
                'falla_baja': 'F03'   # <10V
            },
            'voltaje_alternador': {
                'ideal': 14,
                'min': 12,
                'max': 16,
                'falla_alta': 'F06',  # >16V
                'falla_baja': 'F05'   # <12V
            },
            'temp_vacio': {
                'ideal': 70,
                'min': 50,
                'max': 76,
                'falla_alta': 'F08',  # >76°C
                'falla_baja': 'F07'   # <50°C
            },
            'temp_carga': {
                'ideal': 80,
                'min': 70,
                'max': 90,
                'falla_alta': 'F10',  # >90°C
                'falla_baja': 'F09'   # <70°C
            },
            'nivel_refrigerante': {
                'ideal': 1,  # Sin alarma
                'min': 0,    # BAJO
                'max': 1,    # LLENO
                'falla_baja': 'F11'  # BAJO
            }
        }

        # Códigos de falla
        self.fault_codes = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'F11']

        # Mapear fallas que afectan al mismo parámetro (mutuamente excluyentes)
        self.conflicting_faults = {
            'F01': 'F02',  # Presión aceite baja vs alta
            'F02': 'F01',  # Presión aceite alta vs baja
            'F03': 'F04',  # Voltaje batería bajo vs alto
            'F04': 'F03',  # Voltaje batería alto vs bajo
            'F05': 'F06',  # Voltaje alternador bajo vs alto
            'F06': 'F05',  # Voltaje alternador alto vs bajo
            'F07': 'F08',  # Temp vacío baja vs alta
            'F08': 'F07',  # Temp vacío alta vs baja
            'F09': 'F10',  # Temp carga baja vs alta
            'F10': 'F09'   # Temp carga alta vs baja
        }

    def generate_normal_sample(self) -> Dict:
        """Genera una muestra con parámetros normales (sin fallas)"""
        sample = {}

        # Generar valores normales para cada parámetro
        sample['presion_aceite'] = round(np.random.uniform(2.1, 6.9), 2)
        sample['voltaje_bateria'] = round(np.random.uniform(10.1, 13.9), 2)
        sample['voltaje_alternador'] = round(np.random.uniform(12.1, 15.9), 2)
        sample['temp_vacio'] = round(np.random.uniform(50.1, 75.9), 2)
        sample['temp_carga'] = round(np.random.uniform(70.1, 89.9), 2)
        sample['nivel_refrigerante'] = 1  # Sin alarma

        # Inicializar todas las fallas en 0
        for code in self.fault_codes:
            sample[code] = 0

        return sample

    def generate_fault_sample(self, fault_type: str) -> Dict:
        """Genera una muestra con una falla específica"""
        sample = self.generate_normal_sample()

        # Activar la falla específica
        sample[fault_type] = 1

        # Ajustar el parámetro correspondiente para que coincida con la falla
        if fault_type == 'F01':  # Presión aceite baja
            sample['presion_aceite'] = round(np.random.uniform(0.5, 1.9), 2)
        elif fault_type == 'F02':  # Presión aceite alta
            sample['presion_aceite'] = round(np.random.uniform(7.1, 10.0), 2)
        elif fault_type == 'F03':  # Voltaje batería bajo
            sample['voltaje_bateria'] = round(np.random.uniform(5.0, 9.9), 2)
        elif fault_type == 'F04':  # Voltaje batería alto
            sample['voltaje_bateria'] = round(np.random.uniform(14.1, 18.0), 2)
        elif fault_type == 'F05':  # Voltaje alternador bajo
            sample['voltaje_alternador'] = round(np.random.uniform(8.0, 11.9), 2)
        elif fault_type == 'F06':  # Voltaje alternador alto
            sample['voltaje_alternador'] = round(np.random.uniform(16.1, 20.0), 2)
        elif fault_type == 'F07':  # Temperatura vacío baja
            sample['temp_vacio'] = round(np.random.uniform(20.0, 49.9), 2)
        elif fault_type == 'F08':  # Temperatura vacío alta
            sample['temp_vacio'] = round(np.random.uniform(76.1, 120.0), 2)
        elif fault_type == 'F09':  # Temperatura carga baja
            sample['temp_carga'] = round(np.random.uniform(40.0, 69.9), 2)
        elif fault_type == 'F10':  # Temperatura carga alta
            sample['temp_carga'] = round(np.random.uniform(90.1, 130.0), 2)
        elif fault_type == 'F11':  # Nivel refrigerante bajo
            sample['nivel_refrigerante'] = 0

        return sample

    def get_compatible_faults(self, fault_types: List[str]) -> List[str]:
        """Filtra fallas compatibles (que no se contradigan entre sí)"""
        compatible_faults = []

        for fault in fault_types:
            # Verificar si esta falla es compatible con las ya seleccionadas
            is_compatible = True
            for existing_fault in compatible_faults:
                # Verificar si son fallas conflictivas (afectan al mismo parámetro)
                if fault in self.conflicting_faults and self.conflicting_faults[fault] == existing_fault:
                    is_compatible = False
                    break

            if is_compatible:
                compatible_faults.append(fault)

        return compatible_faults

    def generate_multiple_faults_sample(self, fault_types: List[str]) -> Dict:
        """Genera una muestra con múltiples fallas compatibles"""
        sample = self.generate_normal_sample()

        # Filtrar solo fallas compatibles
        compatible_faults = self.get_compatible_faults(fault_types)

        # Si no hay fallas compatibles, generar una sola falla aleatoria
        if len(compatible_faults) < 2:
            fault_type = random.choice(fault_types)
            return self.generate_fault_sample(fault_type)

        # Activar fallas compatibles
        for fault_type in compatible_faults:
            sample[fault_type] = 1

            # Ajustar parámetros según cada falla
            if fault_type == 'F01':  # Presión aceite baja
                sample['presion_aceite'] = round(np.random.uniform(0.5, 1.9), 2)
            elif fault_type == 'F02':  # Presión aceite alta
                sample['presion_aceite'] = round(np.random.uniform(7.1, 10.0), 2)
            elif fault_type == 'F03':  # Voltaje batería bajo
                sample['voltaje_bateria'] = round(np.random.uniform(5.0, 9.9), 2)
            elif fault_type == 'F04':  # Voltaje batería alto
                sample['voltaje_bateria'] = round(np.random.uniform(14.1, 18.0), 2)
            elif fault_type == 'F05':  # Voltaje alternador bajo
                sample['voltaje_alternador'] = round(np.random.uniform(8.0, 11.9), 2)
            elif fault_type == 'F06':  # Voltaje alternador alto
                sample['voltaje_alternador'] = round(np.random.uniform(16.1, 20.0), 2)
            elif fault_type == 'F07':  # Temperatura vacío baja
                sample['temp_vacio'] = round(np.random.uniform(20.0, 49.9), 2)
            elif fault_type == 'F08':  # Temperatura vacío alta
                sample['temp_vacio'] = round(np.random.uniform(76.1, 120.0), 2)
            elif fault_type == 'F09':  # Temperatura carga baja
                sample['temp_carga'] = round(np.random.uniform(40.0, 69.9), 2)
            elif fault_type == 'F10':  # Temperatura carga alta
                sample['temp_carga'] = round(np.random.uniform(90.1, 130.0), 2)
            elif fault_type == 'F11':  # Nivel refrigerante bajo
                sample['nivel_refrigerante'] = 0

        return sample

    def generate_dataset(self, total_samples: int = 1000) -> pd.DataFrame:
        """Genera el dataset completo"""
        samples = []

        # Distribución de muestras
        normal_samples = int(total_samples * 0.6)  # 60% normales
        single_fault_samples = int(total_samples * 0.3)  # 30% falla única
        multiple_fault_samples = int(total_samples * 0.1)  # 10% fallas múltiples

        print(f"Generando {total_samples} muestras:")
        print(f"- {normal_samples} muestras normales")
        print(f"- {single_fault_samples} muestras con falla única")
        print(f"- {multiple_fault_samples} muestras con fallas múltiples")

        # Generar muestras normales
        for i in range(normal_samples):
            samples.append(self.generate_normal_sample())

        # Generar muestras con falla única
        for i in range(single_fault_samples):
            fault_type = random.choice(self.fault_codes)
            samples.append(self.generate_fault_sample(fault_type))

        # Generar muestras con fallas múltiples
        for i in range(multiple_fault_samples):
            # Generar entre 2 y 4 fallas, pero asegurar compatibilidad
            max_attempts = 10
            for attempt in range(max_attempts):
                num_faults = random.randint(2, 4)
                fault_types = random.sample(self.fault_codes, num_faults)
                compatible_faults = self.get_compatible_faults(fault_types)

                if len(compatible_faults) >= 2:
                    samples.append(self.generate_multiple_faults_sample(fault_types))
                    break
            else:
                # Si no se pueden generar fallas múltiples compatibles, generar una sola
                fault_type = random.choice(self.fault_codes)
                samples.append(self.generate_fault_sample(fault_type))

        # Crear DataFrame
        df = pd.DataFrame(samples)

        # Reordenar columnas
        param_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                        'temp_vacio', 'temp_carga', 'nivel_refrigerante']
        fault_columns = self.fault_codes
        df = df[param_columns + fault_columns]

        # Mezclar las filas
        df = df.sample(frac=1).reset_index(drop=True)

        return df

    def validate_dataset(self, df: pd.DataFrame) -> bool:
        """Valida que el dataset no tenga contradicciones"""
        print("\nValidando dataset...")
        contradictions = 0

        for idx, row in df.iterrows():
            # Validar cada falla
            if row['F01'] == 1 and row['presion_aceite'] >= 2:
                print(f"Contradicción en fila {idx}: F01=1 pero presión_aceite={row['presion_aceite']} >= 2")
                contradictions += 1

            if row['F02'] == 1 and row['presion_aceite'] <= 7:
                print(f"Contradicción en fila {idx}: F02=1 pero presión_aceite={row['presion_aceite']} <= 7")
                contradictions += 1

            if row['F03'] == 1 and row['voltaje_bateria'] >= 10:
                print(f"Contradicción en fila {idx}: F03=1 pero voltaje_bateria={row['voltaje_bateria']} >= 10")
                contradictions += 1

            if row['F04'] == 1 and row['voltaje_bateria'] <= 14:
                print(f"Contradicción en fila {idx}: F04=1 pero voltaje_bateria={row['voltaje_bateria']} <= 14")
                contradictions += 1

            if row['F05'] == 1 and row['voltaje_alternador'] >= 12:
                print(f"Contradicción en fila {idx}: F05=1 pero voltaje_alternador={row['voltaje_alternador']} >= 12")
                contradictions += 1

            if row['F06'] == 1 and row['voltaje_alternador'] <= 16:
                print(f"Contradicción en fila {idx}: F06=1 pero voltaje_alternador={row['voltaje_alternador']} <= 16")
                contradictions += 1

            if row['F07'] == 1 and row['temp_vacio'] >= 50:
                print(f"Contradicción en fila {idx}: F07=1 pero temp_vacio={row['temp_vacio']} >= 50")
                contradictions += 1

            if row['F08'] == 1 and row['temp_vacio'] <= 76:
                print(f"Contradicción en fila {idx}: F08=1 pero temp_vacio={row['temp_vacio']} <= 76")
                contradictions += 1

            if row['F09'] == 1 and row['temp_carga'] >= 70:
                print(f"Contradicción en fila {idx}: F09=1 pero temp_carga={row['temp_carga']} >= 70")
                contradictions += 1

            if row['F10'] == 1 and row['temp_carga'] <= 90:
                print(f"Contradicción en fila {idx}: F10=1 pero temp_carga={row['temp_carga']} <= 90")
                contradictions += 1

            if row['F11'] == 1 and row['nivel_refrigerante'] != 0:
                print(f"Contradicción en fila {idx}: F11=1 pero nivel_refrigerante={row['nivel_refrigerante']} != 0")
                contradictions += 1

        if contradictions == 0:
            print("✅ Dataset validado: No hay contradicciones")
            return True
        else:
            print(f"❌ Se encontraron {contradictions} contradicciones")
            return False

    def print_statistics(self, df: pd.DataFrame):
        """Imprime estadísticas del dataset"""
        print("\n=== ESTADÍSTICAS DEL DATASET ===")
        print(f"Total de muestras: {len(df)}")

        # Estadísticas de fallas
        print("\nDistribución de fallas:")
        for code in self.fault_codes:
            count = df[code].sum()
            percentage = (count / len(df)) * 100
            print(f"{code}: {count} muestras ({percentage:.1f}%)")

        # Muestras sin fallas
        no_faults = df[self.fault_codes].sum(axis=1) == 0
        no_fault_count = no_faults.sum()
        no_fault_percentage = (no_fault_count / len(df)) * 100
        print(f"Sin fallas: {no_fault_count} muestras ({no_fault_percentage:.1f}%)")

        # Estadísticas de parámetros
        print("\nEstadísticas de parámetros:")
        param_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                        'temp_vacio', 'temp_carga', 'nivel_refrigerante']

        for param in param_columns:
            print(f"\n{param}:")
            print(f"  Min: {df[param].min()}")
            print(f"  Max: {df[param].max()}")
            print(f"  Media: {df[param].mean():.2f}")
            print(f"  Desv. Std: {df[param].std():.2f}")

def main():
    # Crear generador
    generator = DatasetGenerator()

    # Generar dataset
    print("Iniciando generación del dataset...")
    df = generator.generate_dataset(total_samples=1000)

    # Validar dataset
    is_valid = generator.validate_dataset(df)

    if is_valid:
        # Guardar dataset
        filename = "dataset_entrenamiento_corregido.csv"
        df.to_csv(filename, index=False)
        print(f"\n✅ Dataset guardado como: {filename}")

        # Imprimir estadísticas
        generator.print_statistics(df)

        # Mostrar primeras 10 filas
        print("\n=== PRIMERAS 10 FILAS DEL DATASET ===")
        print(df.head(10).to_string())

    else:
        print("\n❌ El dataset contiene contradicciones. Revisa la lógica de generación.")

if __name__ == "__main__":
    main()

"""##NUEVOS DATOS

"""

# prompt: Podrias generar un dataset nuevo pero sin las columnas de fallas como el codigo anterior:

import pandas as pd
import numpy as np
from typing import Dict # Import Dict from typing

class DatasetGeneratorNoFaults:
    def __init__(self):
        # Definir los rangos para cada parámetro (considerando rangos normales)
        self.parameters = {
            'presion_aceite': {
                'min': 2.1,
                'max': 6.9,
            },
            'voltaje_bateria': {
                'min': 10.1,
                'max': 13.9,
            },
            'voltaje_alternador': {
                'min': 12.1,
                'max': 15.9,
            },
            'temp_vacio': {
                'min': 50.1,
                'max': 75.9,
            },
            'temp_carga': {
                'min': 70.1,
                'max': 89.9,
            },
            'nivel_refrigerante': {
                'value': 1, # Nivel normal
            }
        }

    def generate_sample(self) -> Dict:
        """Genera una muestra con parámetros dentro del rango normal"""
        sample = {}

        # Generar valores dentro del rango normal para cada parámetro
        sample['presion_aceite'] = round(np.random.uniform(self.parameters['presion_aceite']['min'], self.parameters['presion_aceite']['max']), 2)
        sample['voltaje_bateria'] = round(np.random.uniform(self.parameters['voltaje_bateria']['min'], self.parameters['voltaje_bateria']['max']), 2)
        sample['voltaje_alternador'] = round(np.random.uniform(self.parameters['voltaje_alternador']['min'], self.parameters['voltaje_alternador']['max']), 2)
        sample['temp_vacio'] = round(np.random.uniform(self.parameters['temp_vacio']['min'], self.parameters['temp_vacio']['max']), 2)
        sample['temp_carga'] = round(np.random.uniform(self.parameters['temp_carga']['min'], self.parameters['temp_carga']['max']), 2)
        sample['nivel_refrigerante'] = self.parameters['nivel_refrigerante']['value']

        return sample

    def generate_dataset(self, total_samples: int = 50) -> pd.DataFrame:
        """Genera el dataset completo sin columnas de fallas"""
        samples = []

        print(f"Generando {total_samples} muestras sin fallas...")

        # Generar muestras normales
        for i in range(total_samples):
            samples.append(self.generate_sample())
            if (i + 1) % 5000 == 0:
                print(f"  Generadas {i + 1}/{total_samples} muestras")


        print("Creando DataFrame...")
        # Crear DataFrame
        df = pd.DataFrame(samples)

        # Reordenar columnas
        param_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                        'temp_vacio', 'temp_carga', 'nivel_refrigerante']
        df = df[param_columns]

        print("Mezclando filas...")
        # Mezclar las filas
        df = df.sample(frac=1).reset_index(drop=True)

        return df

    def print_statistics(self, df: pd.DataFrame):
        """Imprime estadísticas del dataset"""
        print("\n=== ESTADÍSTICAS DEL DATASET SIN FALLAS ===")
        print(f"Total de muestras: {len(df)}")

        # Estadísticas de parámetros
        print("\nEstadísticas de parámetros:")
        param_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                        'temp_vacio', 'temp_carga', 'nivel_refrigerante']

        for param in param_columns:
            print(f"\n{param}:")
            print(f"  Min: {df[param].min()}")
            print(f"  Max: {df[param].max()}")
            print(f"  Media: {df[param].mean():.2f}")
            print(f"  Desv. Std: {df[param].std():.2f}")

# Uso de la nueva clase para generar un dataset sin fallas
def main_no_faults():
    # Crear generador sin fallas
    generator_no_faults = DatasetGeneratorNoFaults()

    # Generar dataset de 50,000 muestras sin fallas
    print("Iniciando generación del dataset sin fallas...")
    df_no_faults = generator_no_faults.generate_dataset(total_samples=50000)

    # Guardar dataset
    filename_no_faults = "dataset_sin_fallas_50k.csv"
    print(f"\nGuardando dataset sin fallas como: {filename_no_faults}...")
    df_no_faults.to_csv(filename_no_faults, index=False)
    print(f"✅ Dataset sin fallas guardado como: {filename_no_faults}")

    # Imprimir estadísticas
    generator_no_faults.print_statistics(df_no_faults)

    # Mostrar primeras 10 filas
    print("\n=== PRIMERAS 10 FILAS DEL DATASET SIN FALLAS ===")
    print(df_no_faults.head(10).to_string())

if __name__ == "__main__":
    # Puedes comentar la llamada a main() si solo quieres generar el dataset sin fallas
    # main()
    main_no_faults()

"""##MATRIZ DE CONFUSIÓN CON DATASET NUEVO"""

# Montar Google Drive para cargar el nuevo dataset
drive.mount('/content/drive')

# Definir la ruta al nuevo dataset de prueba en Google Drive
# ¡ATENCIÓN! Reemplaza esta ruta con la ubicación real de tu archivo CSV de prueba
TEST_DATASET_PATH = "/content/drive/MyDrive/Colab Notebooks/TESISS/ELCONDADOFINAL/FINALDEFINALES/lovable/dataset_entrenamiento_corregido.csv"

# Definir la ruta al modelo entrenado en Google Drive
# ¡ATENCIÓN! Reemplaza esta ruta con la ubicación real de tu archivo PKL del modelo
TRAINED_MODEL_PATH = "/content/drive/MyDrive/Colab Notebooks/TESISS/ELCONDADOFINAL/FINALDEFINALES/lovable/modelo_fallas.pkl"

def load_test_data(file_path):
    """Carga un dataset de prueba y separa características y etiquetas."""
    try:
        df_test = pd.read_csv(file_path)

        # Asumir que las columnas de características y etiquetas son las mismas que en el entrenamiento
        feature_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                          'temp_vacio', 'temp_carga', 'nivel_refrigerante']
        target_columns = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'F11']

        # Verificar que las columnas esperadas existen en el dataset de prueba
        if not all(col in df_test.columns for col in feature_columns + target_columns):
            missing_cols = [col for col in feature_columns + target_columns if col not in df_test.columns]
            raise ValueError(f"El dataset de prueba no contiene todas las columnas necesarias. Faltan: {missing_cols}")

        X_test = df_test[feature_columns]
        y_test = df_test[target_columns]

        print(f"\nDataset de prueba cargado desde: {file_path}")
        print(f"Características de prueba (X_test): {X_test.shape}")
        print(f"Etiquetas de prueba (y_test): {y_test.shape}")

        return X_test, y_test, feature_columns, target_columns

    except FileNotFoundError:
        print(f"❌ Error: No se encontró el archivo del dataset de prueba en la ruta: {file_path}")
        return None, None, None, None
    except ValueError as ve:
        print(f"❌ Error en la estructura del dataset de prueba: {ve}")
        return None, None, None, None
    except Exception as e:
        print(f"❌ Ocurrió un error al cargar el dataset de prueba: {str(e)}")
        return None, None, None, None


def load_trained_model_from_drive(file_path):
    """Carga el modelo entrenado desde Google Drive."""
    try:
        model_data = joblib.load(file_path)
        model = model_data['model']
        feature_columns = model_data['feature_columns']
        target_columns = model_data['target_columns']
        print(f"\nModelo entrenado cargado desde: {file_path}")
        return model, feature_columns, target_columns
    except FileNotFoundError:
        print(f"❌ Error: No se encontró el modelo entrenado en la ruta: {file_path}")
        print("Asegúrate de que el archivo 'modelo_fallas.pkl' existe en la ruta especificada y que has ejecutado el script de entrenamiento previamente.")
        return None, None, None
    except Exception as e:
        print(f"❌ Ocurrió un error al cargar el modelo: {str(e)}")
        return None, None, None


def generate_confusion_matrices(y_test, y_pred, target_columns):
    """Genera y visualiza las matrices de confusión para cada etiqueta."""
    print("\n=== MATRICES DE CONFUSIÓN CON DATASET DE PRUEBA ===")

    if y_test is None or y_pred is None or target_columns is None:
        print("No se pueden generar matrices de confusión. Datos de prueba o predicciones no disponibles.")
        return

    # Asegurarse de que y_test es un DataFrame para usar iloc si es necesario
    if not isinstance(y_test, pd.DataFrame):
         y_test = pd.DataFrame(y_test, columns=target_columns)


    mlcm = multilabel_confusion_matrix(y_test, y_pred)

    for i, fault in enumerate(target_columns):
        cm = mlcm[i]
        # mlcm gives [[tn, fp], [fn, tp]]
        tn, fp, fn, tp = cm.ravel()

        print(f"\n--- Matriz de Confusión para {fault} ---")
        print(f"True Negatives (TN): {tn}")
        print(f"False Positives (FP): {fp}")
        print(f"False Negatives (FN): {fn}")
        print(f"True Positives (TP): {tp}")

        # Calcular métricas básicas para esta etiqueta
        total_samples = tn + fp + fn + tp
        accuracy_label = (tn + tp) / total_samples if total_samples > 0 else 0
        precision = tp / (tp + fp) if (tp + fp) > 0 else 0
        recall = tp / (tp + fn) if (tp + fn) > 0 else 0
        f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

        print(f"  Accuracy: {accuracy_label:.4f}")
        print(f"  Precision: {precision:.4f}")
        print(f"  Recall: {recall:.4f}")
        print(f"  F1-Score: {f1:.4f}")


        # Visualizar la matriz de confusión
        plt.figure(figsize=(5, 4))
        sns.heatmap([[tn, fp], [fn, tp]], annot=True, fmt='d', cmap='Blues',
                    xticklabels=['Predicted Negative', 'Predicted Positive'],
                    yticklabels=['Actual Negative', 'Actual Positive'])
        plt.title(f'Confusion Matrix for {fault}')
        plt.xlabel('Predicted Label')
        plt.ylabel('True Label')
        plt.show()


# ===================== EJECUCIÓN PRINCIPAL PARA GENERAR MATRICES DE CONFUSIÓN =====================

# 1. Cargar el dataset de prueba
X_test, y_test, feature_columns, target_columns = load_test_data(TEST_DATASET_PATH)

if X_test is not None and y_test is not None:
    # 2. Cargar el modelo entrenado
    model, loaded_feature_cols, loaded_target_cols = load_trained_model_from_drive(TRAINED_MODEL_PATH)

    if model is not None:
        # Opcional: Verificar que las columnas del modelo coincidan con las del dataset de prueba
        if loaded_feature_cols != feature_columns or loaded_target_cols != target_columns:
             print("⚠️ Advertencia: Las columnas de características/etiquetas del modelo cargado no coinciden exactamente con las del dataset de prueba.")
             print("  Columnas de características del modelo:", loaded_feature_cols)
             print("  Columnas de características del dataset de prueba:", feature_columns)
             print("  Columnas de etiquetas del modelo:", loaded_target_cols)
             print("  Columnas de etiquetas del dataset de prueba:", target_columns)
             # Decide si quieres continuar o detenerte. Aquí, continuamos asumiendo que el orden y nombre son consistentes.


        # 3. Hacer predicciones en el dataset de prueba
        print("\nHaciendo predicciones en el dataset de prueba...")
        try:
             y_pred_test = model.predict(X_test)
             print("Predicciones completadas.")

             # 4. Generar y mostrar las matrices de confusión
             generate_confusion_matrices(y_test, y_pred_test, target_columns)

        except Exception as e:
             print(f"❌ Ocurrió un error al hacer predicciones o generar matrices de confusión: {str(e)}")

    else:
        print("\nNo se pudo cargar el modelo entrenado. No se generarán matrices de confusión.")

else:
    print("\nNo se pudo cargar el dataset de prueba. No se generarán matrices de confusión.")

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.multioutput import MultiOutputClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score, hamming_loss
import joblib

# ===================== CARGAR DATASET =====================
def load_and_prepare_data():
    """Carga el dataset y separa características y etiquetas"""
    df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/TESISS/ELCONDADOFINAL/FINALDEFINALES/lovable/dataset_entrenamiento_50k.csv")

    # Separar características (X) y etiquetas (y)
    feature_columns = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
                      'temp_vacio', 'temp_carga', 'nivel_refrigerante']
    target_columns = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'F11']

    X = df[feature_columns]
    y = df[target_columns]

    print(f"Características (X): {X.shape}")
    print(f"Etiquetas (y): {y.shape}")

    return X, y, feature_columns, target_columns

def train_model(X, y):
    """Entrena el modelo RandomForestClassifier con MultiOutputClassifier"""
    print("\nDividiendo datos en entrenamiento y prueba (80-20)...")
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y.sum(axis=1))

    print("Entrenando modelo RandomForest con MultiOutput...")

    # Crear el modelo
    rf = RandomForestClassifier(
        n_estimators=100,
        max_depth=10,
        min_samples_split=5,
        min_samples_leaf=2,
        random_state=42,
        n_jobs=-1
    )

    # Envolver con MultiOutputClassifier
    model = MultiOutputClassifier(rf)

    # Entrenar
    model.fit(X_train, y_train)

    # Hacer predicciones
    print("Realizando predicciones...")
    y_pred = model.predict(X_test)

    return model, X_test, y_test, y_pred

def evaluate_model(y_test, y_pred, target_columns):
    """Evalúa el rendimiento del modelo"""
    print("\n=== EVALUACIÓN DEL MODELO ===")

    # Accuracy general
    accuracy = accuracy_score(y_test, y_pred)
    print(f"Accuracy general: {accuracy:.4f}")

    # Hamming Loss (para problemas multi-output)
    hamming = hamming_loss(y_test, y_pred)
    print(f"Hamming Loss: {hamming:.4f}")

    # Reporte por cada falla
    print("\nReporte detallado por falla:")
    for i, fault in enumerate(target_columns):
        print(f"\n--- {fault} ---")
        print(classification_report(y_test.iloc[:, i], y_pred[:, i], zero_division=0))

def save_model(model, feature_columns, target_columns, filename="modelo_fallas.pkl"):
    """Guarda el modelo entrenado"""
    model_data = {
        'model': model,
        'feature_columns': feature_columns,
        'target_columns': target_columns
    }

    joblib.dump(model_data, filename)
    print(f"\n✅ Modelo guardado como: {filename}")

def predict_sample(model, feature_columns, target_columns, sample_data):
    """Hace una predicción con datos de muestra"""
    # Crear DataFrame con los datos de entrada
    df_sample = pd.DataFrame([sample_data], columns=feature_columns)

    # Hacer predicción
    prediction = model.predict(df_sample)[0]
    probabilities = model.predict_proba(df_sample)

    print("\n=== PREDICCIÓN DE MUESTRA ===")
    print("Datos de entrada:")
    for i, feature in enumerate(feature_columns):
        print(f"  {feature}: {sample_data[i]}")

    print("\nFallas detectadas:")
    detected_faults = []
    for i, fault in enumerate(target_columns):
        if prediction[i] == 1:
            # Ensure probabilities[i] is not empty and has the expected structure
            prob = probabilities[i][0][1] if len(probabilities[i]) > 0 and len(probabilities[i][0]) > 1 else 0
            print(f"  {fault}: SÍ (probabilidad: {prob:.3f})")
            detected_faults.append(fault)
        else:
            # Ensure probabilities[i] is not empty and has the expected structure
            prob = probabilities[i][0][0] if len(probabilities[i]) > 0 and len(probabilities[i][0]) > 1 else 1
            print(f"  {fault}: NO (probabilidad: {1-prob:.3f})")


    if not detected_faults:
        print("  ✅ No se detectaron fallas")
    else:
        print(f"  ⚠️ Fallas detectadas: {', '.join(detected_faults)}")

def main():
    try:
        # Cargar datos
        X, y, feature_columns, target_columns = load_and_prepare_data()

        # Entrenar modelo
        model, X_test, y_test, y_pred = train_model(X, y)

        # Evaluar modelo
        evaluate_model(y_test, y_pred, target_columns)

        # Guardar modelo
        save_model(model, feature_columns, target_columns)

        # Ejemplo de predicción
        print("\n" + "="*50)
        print("EJEMPLO DE PREDICCIÓN")
        print("="*50)

        # Muestra normal
        sample_normal = [5.2, 12.8, 14.1, 68.5, 82.3, 1]  # Sin fallas
        predict_sample(model, feature_columns, target_columns, sample_normal)

        # Muestra con falla
        sample_fault = [1.5, 8.5, 17.2, 45.0, 95.0, 0]  # Múltiples fallas
        predict_sample(model, feature_columns, target_columns, sample_fault)

    except FileNotFoundError:
        print("❌ Error: No se encontró el archivo del dataset.")
        print("Primero ejecuta 'python dataset_generator.py' para generar el dataset.")
    except Exception as e:
        print(f"❌ Error durante el entrenamiento: {str(e)}")

if __name__ == "__main__":
    main()

"""**DASHBOARD BÁSICO**"""

import pandas as pd
import joblib
import numpy as np

def load_trained_model(filename="modelo_fallas.pkl"):
    """Carga el modelo entrenado"""
    try:
        model_data = joblib.load(filename)
        return model_data['model'], model_data['feature_columns'], model_data['target_columns']
    except FileNotFoundError:
        print("❌ Error: No se encontró el modelo entrenado.")
        print("Primero ejecuta 'python train_model.py' para entrenar el modelo.")
        return None, None, None

def diagnose_system(presion_aceite, voltaje_bateria, voltaje_alternador,
                   temp_vacio, temp_carga, nivel_refrigerante):
    """Diagnostica el sistema basado en los parámetros de entrada"""

    # Cargar modelo
    model, feature_columns, target_columns = load_trained_model()
    if model is None:
        return

    # Preparar datos
    sample_data = [presion_aceite, voltaje_bateria, voltaje_alternador,
                  temp_vacio, temp_carga, nivel_refrigerante]
    df_sample = pd.DataFrame([sample_data], columns=feature_columns)

    # Hacer predicción
    prediction = model.predict(df_sample)[0]
    probabilities = model.predict_proba(df_sample)

    print("="*60)
    print("DIAGNÓSTICO DEL SISTEMA")
    print("="*60)

    # Mostrar parámetros de entrada
    print("Parámetros del sistema:")
    print(f"  Presión de Aceite: {presion_aceite} psi")
    print(f"  Voltaje Batería: {voltaje_bateria} V")
    print(f"  Voltaje Alternador: {voltaje_alternador} V")
    print(f"  Temperatura (Vacío): {temp_vacio} °C")
    print(f"  Temperatura (Carga): {temp_carga} °C")
    print(f"  Nivel Refrigerante: {'LLENO' if nivel_refrigerante == 1 else 'BAJO'}")

    print("\n" + "-"*60)

    # Analizar fallas
    detected_faults = []
    fault_descriptions = {
        'F01': 'Presión de aceite baja (<2 psi)',
        'F02': 'Presión de aceite alta (>7 psi)',
        'F03': 'Voltaje de batería bajo (<10V)',
        'F04': 'Voltaje de batería alto (>14V)',
        'F05': 'Voltaje de alternador bajo (<12V)',
        'F06': 'Voltaje de alternador alto (>16V)',
        'F07': 'Temperatura en vacío baja (<50°C)',
        'F08': 'Temperatura en vacío alta (>76°C)',
        'F09': 'Temperatura en carga baja (<70°C)',
        'F10': 'Temperatura en carga alta (>90°C)',
        'F11': 'Nivel de refrigerante bajo'
    }

    print("RESULTADOS DEL DIAGNÓSTICO:")

    for i, fault in enumerate(target_columns):
        if prediction[i] == 1:
            prob = probabilities[i][0][1] if len(probabilities[i][0]) > 1 else 0
            print(f"  ⚠️  {fault}: {fault_descriptions[fault]} (Confianza: {prob:.1%})")
            detected_faults.append(fault)

    if not detected_faults:
        print("  ✅ SISTEMA NORMAL - No se detectaron fallas")
    else:
        print(f"\n  🚨 TOTAL DE FALLAS DETECTADAS: {len(detected_faults)}")

        # Clasificar severidad
        critical_faults = [f for f in detected_faults if f in ['F01', 'F03', 'F11']]
        if critical_faults:
            print("  🔴 FALLAS CRÍTICAS detectadas - Revisar inmediatamente")
        else:
            print("  🟡 Fallas detectadas - Programar mantenimiento")

    print("="*60)

def interactive_diagnosis():
    """Modo interactivo para diagnóstico"""
    print("SISTEMA DE DIAGNÓSTICO INTERACTIVO")
    print("="*40)

    try:
        presion_aceite = float(input("Presión de Aceite (psi): "))
        voltaje_bateria = float(input("Voltaje de Batería (V): "))
        voltaje_alternador = float(input("Voltaje de Alternador (V): "))
        temp_vacio = float(input("Temperatura en Vacío (°C): "))
        temp_carga = float(input("Temperatura en Carga (°C): "))
        nivel_refrigerante = int(input("Nivel de Refrigerante (1=LLENO, 0=BAJO): "))

        diagnose_system(presion_aceite, voltaje_bateria, voltaje_alternador,
                       temp_vacio, temp_carga, nivel_refrigerante)

    except ValueError:
        print("❌ Error: Por favor ingresa valores numéricos válidos")
    except KeyboardInterrupt:
        print("\n\nDiagnóstico cancelado por el usuario.")

def test_scenarios():
    """Prueba varios escenarios de diagnóstico"""
    print("PROBANDO ESCENARIOS DE DIAGNÓSTICO")
    print("="*40)

    scenarios = [
        {
            'name': 'Sistema Normal',
            'params': [5.2, 12.8, 14.1, 68.5, 82.3, 1]
        },
        {
            'name': 'Presión de Aceite Baja',
            'params': [1.5, 12.8, 14.1, 68.5, 82.3, 1]
        },
        {
            'name': 'Voltaje de Batería Alto',
            'params': [5.2, 15.2, 14.1, 68.5, 82.3, 1]
        },
        {
            'name': 'Múltiples Fallas',
            'params': [1.8, 8.5, 17.2, 45.0, 95.0, 0]
        },
        {
            'name': 'Temperatura Alta en Carga',
            'params': [5.2, 12.8, 14.1, 68.5, 95.5, 1]
        }
    ]

    for scenario in scenarios:
        print(f"\nESCENARIO: {scenario['name']}")
        print("-" * 30)
        diagnose_system(*scenario['params'])
        print()

def main():
    print("SISTEMA DE DIAGNÓSTICO DE FALLAS")
    print("="*50)
    print("1. Diagnóstico interactivo")
    print("2. Probar escenarios predefinidos")
    print("3. Salir")

    while True:
        try:
            choice = input("\nSelecciona una opción (1-3): ").strip()

            if choice == '1':
                interactive_diagnosis()
            elif choice == '2':
                test_scenarios()
            elif choice == '3':
                print("¡Hasta luego!")
                break
            else:
                print("Opción inválida. Por favor selecciona 1, 2 o 3.")

        except KeyboardInterrupt:
            print("\n\n¡Hasta luego!")
            break

if __name__ == "__main__":
    main()

"""**DASHBOARD CON DATASET PRUEBA**"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import time
import joblib
from plotly.subplots import make_subplots

# Configuración de la página
st.set_page_config(
    page_title="Dashboard de Monitoreo Generador",
    page_icon="🚗",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Tabla de referencias para fallas
FAULT_REFERENCE = {
    'F01': {
        'parameter': 'Presión de Aceite',
        'condition': '<2 psi',
        'description': 'Bomba en mal estado o falta de aceite',
        'action': 'Verificar nivel y filtro de aceite; revisar bomba y sensores',
        'urgency': 'Crítica',
        'type': 'Mecánica'
    },
    'F02': {
        'parameter': 'Presión de Aceite',
        'condition': '>7 psi',
        'description': 'Bomba en mal estado o exceso de aceite',
        'action': 'Verificar viscosidad del aceite; revisar válvula reguladora de presión',
        'urgency': 'Inmediata',
        'type': 'Mecánica'
    },
    'F03': {
        'parameter': 'Voltaje de Batería',
        'condition': '<10V',
        'description': 'Batería descargada o en mal estado',
        'action': 'Cargar batería; limpiar bornes; reemplazar si es necesario',
        'urgency': 'Crítica',
        'type': 'Eléctrica'
    },
    'F04': {
        'parameter': 'Voltaje de Batería',
        'condition': '>14V',
        'description': 'Falla en cargador de batería o alternador',
        'action': 'Verificar regulador de voltaje; revisar fusibles y conexiones',
        'urgency': 'Inmediata',
        'type': 'Eléctrica'
    },
    'F05': {
        'parameter': 'Voltaje Alternador',
        'condition': '<12V',
        'description': 'Bobinas abiertas o carbones desgastados',
        'action': 'Cambiar carbones; revisar diodos y bobinados',
        'urgency': 'Inmediata',
        'type': 'Eléctrica'
    },
    'F06': {
        'parameter': 'Voltaje Alternador',
        'condition': '>16V',
        'description': 'Daño en tarjeta reguladora o cortocircuito',
        'action': 'Reemplazar regulador; inspeccionar cortocircuitos',
        'urgency': 'Crítica',
        'type': 'Eléctrica'
    },
    'F07': {
        'parameter': 'Temperatura (Vacío)',
        'condition': '<50°C',
        'description': 'Termostato atascado o calentador de camisa dañado',
        'action': 'Revisar termostato; probar calentador de camisa',
        'urgency': 'Preventiva',
        'type': 'Térmica'
    },
    'F08': {
        'parameter': 'Temperatura (Vacío)',
        'condition': '>76°C',
        'description': 'Radiador obstruido o falla de termostatos',
        'action': 'Limpiar radiador; reemplazar termostatos; verificar ventilación',
        'urgency': 'Crítica',
        'type': 'Térmica'
    },
    'F09': {
        'parameter': 'Temperatura (Carga)',
        'condition': '<70°C',
        'description': 'Sensor de temperatura defectuoso',
        'action': 'Calibrar o reemplazar sensor; verificar conexiones',
        'urgency': 'Preventiva',
        'type': 'Térmica'
    },
    'F10': {
        'parameter': 'Temperatura (Carga)',
        'condition': '>90°C',
        'description': 'Obstrucción en radiador o bomba de agua defectuosa',
        'action': 'Limpieza profunda del sistema; cambiar refrigerante; revisar bomba y ventilador',
        'urgency': 'Crítica',
        'type': 'Térmica'
    },
    'F11': {
        'parameter': 'Nivel de Refrigerante',
        'condition': 'BAJO',
        'description': 'Fuga en sellos o radiador',
        'action': 'Reponer refrigerante; inspeccionar fugas (bomba, mangueras, radiador)',
        'urgency': 'Inmediata',
        'type': 'Térmica'
    }
}

# Colores por urgencia
URGENCY_COLORS = {
    'Crítica': '#FF4444',
    'Inmediata': '#FF8C00',
    'Preventiva': '#FFD700',
    'Ninguna': '#28A745'
}

@st.cache_data
def load_data():
    """Carga los datos del CSV"""
    try:
        df = pd.read_csv("dataset_entrenamiento_corregido.csv")
        return df
    except FileNotFoundError:
        st.error("❌ No se encontró el archivo dataset_entrenamiento_corregido.cvs")
        return None

def load_model():
    """Carga el modelo entrenado"""
    try:
        model_data = joblib.load("modelo_fallas.pkl")
        return model_data['model'], model_data['feature_columns'], model_data['target_columns']
    except FileNotFoundError:
        st.warning("⚠️ No se encontró el modelo entrenado. Ejecuta train_model.py primero.")
        return None, None, None

def predict_faults(model, feature_columns, sample_data):
    """Predice fallas usando el modelo"""
    if model is None:
        return None, None

    df_sample = pd.DataFrame([sample_data], columns=feature_columns)
    prediction = model.predict(df_sample)[0]
    probabilities = model.predict_proba(df_sample)

    return prediction, probabilities

def get_parameter_status(value, param_name):
    """Determina el estado de un parámetro"""
    ranges = {
        'presion_aceite': {'min': 2, 'max': 7, 'ideal': 5},
        'voltaje_bateria': {'min': 10, 'max': 14, 'ideal': 13},
        'voltaje_alternador': {'min': 12, 'max': 16, 'ideal': 14},
        'temp_vacio': {'min': 50, 'max': 76, 'ideal': 70},
        'temp_carga': {'min': 70, 'max': 90, 'ideal': 80},
        'nivel_refrigerante': {'min': 0, 'max': 1, 'ideal': 1}
    }

    if param_name not in ranges:
        return 'Normal', '#28A745'

    r = ranges[param_name]

    if value < r['min'] or value > r['max']:
        return 'Crítico', '#FF4444'
    elif abs(value - r['ideal']) > (r['max'] - r['min']) * 0.3:
        return 'Advertencia', '#FF8C00'
    else:
        return 'Normal', '#28A745'

def main():
    st.title("🚗 Dashboard de Monitoreo Vehicular")
    st.markdown("---")

    # Cargar datos y modelo
    df = load_data()
    model, feature_columns, target_columns = load_model()

    if df is None:
        st.stop()

    # Sidebar para configuración
    st.sidebar.title("⚙️ Configuración")

    # Simulación de tiempo real
    auto_refresh = st.sidebar.checkbox("🔄 Actualización Automática", value=False)
    refresh_interval = st.sidebar.slider("Intervalo (segundos)", 1, 60, 10)

    # Selector de muestra actual
    if 'current_sample' not in st.session_state:
        st.session_state.current_sample = 0

    max_samples = len(df) - 1
    st.session_state.current_sample = st.sidebar.number_input(
        "Muestra Actual", 0, max_samples, st.session_state.current_sample
    )

    # Botones de control
    col1, col2 = st.sidebar.columns(2)
    if col1.button("⏮️ Anterior"):
        if st.session_state.current_sample > 0:
            st.session_state.current_sample -= 1
            st.rerun()

    if col2.button("⏭️ Siguiente"):
        if st.session_state.current_sample < max_samples:
            st.session_state.current_sample += 1
            st.rerun()

    # Obtener muestra actual
    current_row = df.iloc[st.session_state.current_sample]

    # Crear pestañas
    tab1, tab2, tab3, tab4 = st.tabs([
        "📊 Monitoreo en Tiempo Real",
        "📈 Análisis Histórico",
        "⚠️ Gestión de Fallas",
        "🔧 Recomendaciones"
    ])

    with tab1:
        show_real_time_monitoring(current_row, model, feature_columns, target_columns)

    with tab2:
        show_historical_analysis(df)

    with tab3:
        show_fault_management(current_row, model, feature_columns, target_columns)

    with tab4:
        show_recommendations(current_row, model, feature_columns, target_columns)

    # Auto-refresh
    if auto_refresh:
        time.sleep(refresh_interval)
        if st.session_state.current_sample < max_samples:
            st.session_state.current_sample += 1
        else:
            st.session_state.current_sample = 0
        st.rerun()

def show_real_time_monitoring(current_row, model, feature_columns, target_columns):
    """Muestra el monitoreo en tiempo real"""
    st.header("📊 Estado Actual del Vehículo")

    # Timestamp simulado
    timestamp = datetime.now() - timedelta(minutes=st.session_state.current_sample)
    st.info(f"🕐 Última lectura: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}")

    # Métricas principales
    col1, col2, col3, col4, col5, col6 = st.columns(6)

    params = [
        ('presion_aceite', 'Presión Aceite', 'psi'),
        ('voltaje_bateria', 'Voltaje Batería', 'V'),
        ('voltaje_alternador', 'Voltaje Alternador', 'V'),
        ('temp_vacio', 'Temp. Vacío', '°C'),
        ('temp_carga', 'Temp. Carga', '°C'),
        ('nivel_refrigerante', 'Refrigerante', '')
    ]

    cols = [col1, col2, col3, col4, col5, col6]

    for i, (param, label, unit) in enumerate(params):
        value = current_row[param]
        status, color = get_parameter_status(value, param)

        with cols[i]:
            st.metric(
                label=label,
                value=f"{value:.1f} {unit}",
                delta=status
            )
            st.markdown(f"<div style='color: {color}; text-align: center; font-weight: bold;'>{status}</div>",
                       unsafe_allow_html=True)

    # Gráficos de medidores
    st.markdown("---")
    st.subheader("📈 Medidores en Tiempo Real")

    # Crear gráficos de gauge
    fig_gauges = make_subplots(
        rows=2, cols=3,
        subplot_titles=[p[1] for p in params],
        specs=[[{"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}],
               [{"type": "indicator"}, {"type": "indicator"}, {"type": "indicator"}]]
    )

    ranges = {
        'presion_aceite': [0, 10],
        'voltaje_bateria': [8, 16],
        'voltaje_alternador': [10, 18],
        'temp_vacio': [30, 100],
        'temp_carga': [50, 120],
        'nivel_refrigerante': [0, 1]
    }

    for i, (param, label, unit) in enumerate(params):
        row = (i // 3) + 1
        col = (i % 3) + 1

        value = current_row[param]
        param_range = ranges[param]

        fig_gauges.add_trace(
            go.Indicator(
                mode="gauge+number",
                value=value,
                title={'text': f"{label} ({unit})"},
                gauge={
                    'axis': {'range': param_range},
                    'bar': {'color': "darkblue"},
                    'steps': [
                        {'range': [param_range[0], param_range[1] * 0.5], 'color': "lightgray"},
                        {'range': [param_range[1] * 0.5, param_range[1] * 0.8], 'color': "gray"}
                    ],
                    'threshold': {
                        'line': {'color': "red", 'width': 4},
                        'thickness': 0.75,
                        'value': param_range[1] * 0.9
                    }
                }
            ),
            row=row, col=col
        )

    fig_gauges.update_layout(height=600, showlegend=False)
    st.plotly_chart(fig_gauges, use_container_width=True)

def show_historical_analysis(df):
    """Muestra el análisis histórico"""
    st.header("📈 Análisis Histórico de Parámetros")

    # Selector de parámetros
    params = ['presion_aceite', 'voltaje_bateria', 'voltaje_alternador',
              'temp_vacio', 'temp_carga', 'nivel_refrigerante']
    selected_params = st.multiselect("Seleccionar parámetros", params, default=params[:3])

    if selected_params:
        # Gráfico de líneas temporales
        fig_lines = go.Figure()

        # Simular timestamp
        timestamps = [datetime.now() - timedelta(minutes=i) for i in range(len(df)-1, -1, -1)]

        for param in selected_params:
            fig_lines.add_trace(go.Scatter(
                x=timestamps[:1000],  # Mostrar últimas 1000 muestras
                y=df[param].head(1000),
                mode='lines',
                name=param.replace('_', ' ').title(),
                line=dict(width=2)
            ))

        fig_lines.update_layout(
            title="Evolución Temporal de Parámetros",
            xaxis_title="Tiempo",
            yaxis_title="Valor",
            height=400,
            hovermode='x unified'
        )

        st.plotly_chart(fig_lines, use_container_width=True)

        # Estadísticas por parámetro
        st.subheader("📊 Estadísticas por Parámetro")

        stats_df = df[selected_params].describe().round(2)
        st.dataframe(stats_df, use_container_width=True)

        # Histogramas
        st.subheader("📊 Distribución de Valores")

        cols = st.columns(len(selected_params))
        for i, param in enumerate(selected_params):
            with cols[i]:
                fig_hist = px.histogram(
                    df, x=param,
                    title=param.replace('_', ' ').title(),
                    nbins=30
                )
                fig_hist.update_layout(height=300)
                st.plotly_chart(fig_hist, use_container_width=True)

def show_fault_management(current_row, model, feature_columns, target_columns):
    """Muestra la gestión de fallas"""
    st.header("⚠️ Gestión de Fallas")

    # Predicción de fallas usando el modelo
    if model is not None and feature_columns is not None:
        sample_data = [current_row[col] for col in feature_columns]
        predictions, probabilities = predict_faults(model, feature_columns, sample_data)

        if predictions is not None:
            # Mostrar fallas detectadas
            st.subheader("🔍 Fallas Detectadas")

            detected_faults = []
            for i, fault_code in enumerate(target_columns):
                if predictions[i] == 1:
                    detected_faults.append(fault_code)

            if detected_faults:
                for fault_code in detected_faults:
                    fault_info = FAULT_REFERENCE[fault_code]
                    urgency_color = URGENCY_COLORS[fault_info['urgency']]

                    st.markdown(f"""
                    <div style='border: 2px solid {urgency_color}; border-radius: 10px; padding: 15px; margin: 10px 0;'>
                        <h4 style='color: {urgency_color}; margin: 0;'>🚨 {fault_code} - {fault_info['urgency']}</h4>
                        <p><strong>Parámetro:</strong> {fault_info['parameter']}</p>
                        <p><strong>Condición:</strong> {fault_info['condition']}</p>
                        <p><strong>Descripción:</strong> {fault_info['description']}</p>
                        <p><strong>Tipo:</strong> {fault_info['type']}</p>
                    </div>
                    """, unsafe_allow_html=True)
            else:
                st.success("✅ No se detectaron fallas en la lectura actual")

    # Mostrar fallas reales del dataset
    st.subheader("📋 Fallas Registradas en Dataset")

    fault_columns = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'F11']
    active_faults = []

    for fault in fault_columns:
        if current_row[fault] == 1:
            active_faults.append(fault)

    if active_faults:
        for fault_code in active_faults:
            fault_info = FAULT_REFERENCE[fault_code]
            urgency_color = URGENCY_COLORS[fault_info['urgency']]

            st.markdown(f"""
            <div style='border: 2px solid {urgency_color}; border-radius: 10px; padding: 15px; margin: 10px 0; background-color: rgba(255,255,255,0.1);'>
                <h4 style='color: {urgency_color}; margin: 0;'>⚠️ {fault_code} - {fault_info['urgency']}</h4>
                <p><strong>Parámetro:</strong> {fault_info['parameter']}</p>
                <p><strong>Condición:</strong> {fault_info['condition']}</p>
                <p><strong>Descripción:</strong> {fault_info['description']}</p>
                <p><strong>Tipo:</strong> {fault_info['type']}</p>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.success("✅ No hay fallas registradas en el dataset para esta muestra")

    # Resumen de urgencias
    st.subheader("📊 Resumen por Nivel de Urgencia")

    urgency_counts = {'Crítica': 0, 'Inmediata': 0, 'Preventiva': 0, 'Ninguna': 0}

    for fault in active_faults:
        urgency = FAULT_REFERENCE[fault]['urgency']
        urgency_counts[urgency] += 1

    if sum(urgency_counts.values()) == 0:
        urgency_counts['Ninguna'] = 1

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("🔴 Crítica", urgency_counts['Crítica'])
    with col2:
        st.metric("🟠 Inmediata", urgency_counts['Inmediata'])
    with col3:
        st.metric("🟡 Preventiva", urgency_counts['Preventiva'])
    with col4:
        st.metric("🟢 Ninguna", urgency_counts['Ninguna'])

def show_recommendations(current_row, model, feature_columns, target_columns):
    """Muestra las recomendaciones de mantenimiento"""
    st.header("🔧 Recomendaciones de Mantenimiento")

    # Obtener fallas activas
    fault_columns = ['F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 'F09', 'F10', 'F11']
    active_faults = [fault for fault in fault_columns if current_row[fault] == 1]

    if active_faults:
        # Agrupar por tipo de falla
        fault_types = {}
        for fault_code in active_faults:
            fault_info = FAULT_REFERENCE[fault_code]
            fault_type = fault_info['type']
            if fault_type not in fault_types:
                fault_types[fault_type] = []
            fault_types[fault_type].append(fault_code)

        # Mostrar recomendaciones por tipo
        for fault_type, faults in fault_types.items():
            st.subheader(f"🔧 Mantenimiento {fault_type}")

            for fault_code in faults:
                fault_info = FAULT_REFERENCE[fault_code]
                urgency_color = URGENCY_COLORS[fault_info['urgency']]

                with st.expander(f"{fault_code} - {fault_info['description']}", expanded=True):
                    st.markdown(f"""
                    **Nivel de Urgencia:** <span style='color: {urgency_color}; font-weight: bold;'>{fault_info['urgency']}</span>

                    **Parámetro Afectado:** {fault_info['parameter']}

                    **Condición Detectada:** {fault_info['condition']}

                    **Acción Recomendada:**
                    {fault_info['action']}
                    """, unsafe_allow_html=True)

        # Plan de mantenimiento consolidado
        st.markdown("---")
        st.subheader("📋 Plan de Mantenimiento Consolidado")

        # Priorizar por urgencia
        critical_faults = [f for f in active_faults if FAULT_REFERENCE[f]['urgency'] == 'Crítica']
        immediate_faults = [f for f in active_faults if FAULT_REFERENCE[f]['urgency'] == 'Inmediata']
        preventive_faults = [f for f in active_faults if FAULT_REFERENCE[f]['urgency'] == 'Preventiva']

        if critical_faults:
            st.error("🔴 **ACCIÓN INMEDIATA REQUERIDA**")
            for fault in critical_faults:
                st.write(f"• {fault}: {FAULT_REFERENCE[fault]['action']}")

        if immediate_faults:
            st.warning("🟠 **PROGRAMAR MANTENIMIENTO URGENTE**")
            for fault in immediate_faults:
                st.write(f"• {fault}: {FAULT_REFERENCE[fault]['action']}")

        if preventive_faults:
            st.info("🟡 **MANTENIMIENTO PREVENTIVO**")
            for fault in preventive_faults:
                st.write(f"• {fault}: {FAULT_REFERENCE[fault]['action']}")

        # Estimación de costos (simulada)
        st.subheader("💰 Estimación de Costos")

        cost_estimates = {
            'Crítica': 500,
            'Inmediata': 300,
            'Preventiva': 150
        }

        total_cost = 0
        for fault in active_faults:
            urgency = FAULT_REFERENCE[fault]['urgency']
            total_cost += cost_estimates.get(urgency, 100)

        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Costo Estimado", f"${total_cost:,}")
        with col2:
            st.metric("Tiempo Estimado", f"{len(active_faults) * 2} horas")
        with col3:
            st.metric("Técnicos Requeridos", max(1, len(active_faults) // 2))

    else:
        st.success("✅ **VEHÍCULO EN CONDICIONES ÓPTIMAS**")
        st.info("No se requieren acciones de mantenimiento en este momento.")

        # Recomendaciones preventivas generales
        st.subheader("🔧 Mantenimiento Preventivo Recomendado")

        preventive_actions = [
            "Verificar niveles de fluidos semanalmente",
            "Inspeccionar conexiones eléctricas mensualmente",
            "Limpiar filtros de aire cada 3 meses",
            "Cambiar aceite según programa de mantenimiento",
            "Revisar sistema de refrigeración trimestralmente"
        ]

        for action in preventive_actions:
            st.write(f"• {action}")

if __name__ == "__main__":
    main()